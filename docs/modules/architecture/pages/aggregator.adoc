= Saga Aggregator.

The *aggregator* object is the main place that all the data is stored for the entire transaction.
According to the Place-order example, the entire process has a set of sub processes like

. Fetching user's details.
. Initialize order.
. Make the Pre-Auth process.
. Update the stock.
. Finalize the order by making the real payment.


While executing those atomic processes, you have to store some data regarding the transaction.
For instance, at the initially you can store the order-related data in the aggregator like username of the customer, the total amount, the items that the customer bought, etc.
After that as the 1st execution, the user's data is fetched from the user-service.
to fetch the user's more details, we have to use the username that has been stored in the aggregator object.
and also the user's details are stored in the aggregator object to be used upcoming executions.
That stored user's data will be used for *Initialize order* and *Pre-Auth process*.
and after making the *Pre-Auth process*, a reference ID will be returned from the payment-service for make the real payment.
that reference ID also saved in the aggregator object to

The process is started from creating order.
After creating the order, you have a data to be kept.
As a response, you will get the order id.
You have to keep it, and you have to reuse it in your whole process.
After creating the order, you check the user activeness.
Then the user service is called and get the response of user's activeness and keep that data as user is active at the time of the process started.
Likewise, each and every process will return you to data.
Those data you have to keep in one location.
That location called as the aggregator.
At the start, you have to declare the variables, and after doing each process, you can update the values in the aggregator.
On the other hand, we can say it is the data bucket that you bring the data to each executor.

Another special thing is that the aggregator is used as the key of your entire transaction.
That means the executors are identified by the aggregator class that you use.
Because your entire transaction can have only one aggregator.
Therefore, the aggregator class is used in each and every time by representing the transaction.
For instance, according to the StackSaga example, the place order is the entire process.
It contains many sub processes like create order, check user ect.
Each process is introduced to the framework by using executors.
So, for each process have separate executors.
When you create each executor, you should mention what ks the aggregator that you want to use in that executor.

NOTE: You can store/update the data in the aggregator by using the process execution only (doProcess()).
If you want to keep some metadata while your revert/Compensating processes, you can use the hint-store that the framework provides.

