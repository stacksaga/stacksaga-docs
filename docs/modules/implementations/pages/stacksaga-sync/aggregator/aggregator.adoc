= StackSaga Aggregator

== Overview

The *aggregator* object serves as the central data container for the entire transaction lifecycle.
It acts as a shared data bucket, allowing each xref:stacksaga-sync/executor/executor_architecture.adoc[executor] to access and update transaction-related data as the process progresses.

Whenever an executor runs, it can both read from and write to the aggregator.
This means that data produced or modified by one executor becomes immediately available to subsequent executors, ensuring seamless data flow throughout the transaction.

The aggregator’s state is updated at each significant event, and every version of this state is persisted.
Initially, the aggregator is saved as the transaction’s starting state in the event-store.
After each executor completes, the updated aggregator state's snapshot is again saved, tagged with the executor’s name.
This approach is known as aggregator event sourcing.

*Aggregator event sourcing provides two main benefits:*

. Transaction Retry (Executor Replay)
- If an atomic execution fails due to a transient issue (such as a temporary resource unavailability), the system can retry the operation.
when the retry is done, the transaction should be started where the transaction was stopped previously. to start the transaction from the same point, it has to be restored the same data that was used when the transaction was stopped.

. Transaction Traceability via Dashboard
- By storing every change to the aggregator, the system enables detailed debugging and auditing.
Administrators can inspect the aggregator’s state before and after each executor runs, making it easy to trace the transaction’s evolution step by step through the admin dashboard.

== How to use the aggregator

According to the xref:foundations:introduction-to-saga-design-pattern.adoc[Place-order example], the entire process has a set of sub executions like:

. Fetching user's details. (query execution)
. Initialize order. (command execution)
. Reserve the items. (command execution)
. Make the Payment (command execution)

While executing those atomic processes, you have to store some data regarding each execution.
For instance,

* At the initially, order request related data should be stored in the aggregator to be used in upcoming executions such as username, total amount, items that the customer bought, etc.
* After that, the user's data is fetched from the user-service by using the username that has been stored in the aggregator object. and again, the user's details are stored in the aggregator object to be used in upcoming executions.
* That stored user's data will be used for *Initialize order*.
* Next, to reserve the items, the order ID that is generated from the *Initialize order* execution is used.
* Finally, To make the payment, order ID and the total amount, username that are stored in the aggregator object are used. and also again, the aggregator is updated by storing the reference ID that is returned from the payment-service.

IMPORTANT: In the same way, we have to access that updated data in case of compensating executions. but in the compensating executions, we cannot update the aggregator object. because aggregator is used only for the primary executions in Stacksaga.
the revert hint-store can be used for compensation executions to store any metadata that is required for the compensating executions.

Here is How the aggregator changes while the transaction on each executor.

image:implementations:aggregator/stacksaga-diagram-aggregator-state.svg[alt="stacksaga diagram aggregator state"]

Another special thing is that the aggregator is used as the key of your entire transaction.
That means the executors are identified by the aggregator class that you use.
Because your entire transaction can have only one aggregator.
Therefore, the aggregator class is used in each and every time by representing the transaction.
For instance, according to the StackSaga example, the place order is the entire process.
It contains many sub atomic-transactions like initialize order, check user, etc.
Each process is introduced to the framework by using executors.
So, for each process have separate executors.
When you create each executor, you should mention what is the aggregator that you want to use in that executor.

== Saga Aggregator life cycle summary

- The Saga Aggregator object is created when you start the transaction by accessing the saga orchestration engine.
- After that, the aggregator is updated continuously from time to time by the executors as needed.
- each and every update is saved in the event-store after executing each executor by serializing as a JSON object.
- if the transaction is failed as a retryable one, the aggregator object is restored by the orchestration engine when the transaction is trying to invoke.

== Implementation Related topics

* xref:stacksaga-sync/aggregator/create-aggregator.adoc[Creating Aggregator Class]
* xref:stacksaga-sync/aggregator/aggregator_mapper_implementation.adoc[Custom Aggregator Mapper]
* xref:stacksaga-sync/aggregator/saga_serializable.adoc[Aggregator Serialization And Deserialization]
* xref:stacksaga-sync/aggregator/aggregator_key_gen_custom_implementation.adoc[Aggregator KeyGen]
* xref:stacksaga-sync/aggregator/aggregator_casting.adoc[Aggregator Event Casting]
