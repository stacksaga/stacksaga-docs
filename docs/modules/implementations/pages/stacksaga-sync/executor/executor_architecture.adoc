= Saga Executors

== Overview

A Saga Executor in StackSaga is a specialized component responsible for encapsulating and executing a single atomic transaction within a distributed saga workflow.
It acts as the bridge between your business logic and the saga orchestration engine, ensuring that each step in a long-running transaction is performed reliably and consistently.
Saga Executors are categorized as either command executors (handling both primary and compensating executions for operations that modify state) or query executors (handling read-only operations).
By isolating each atomic transaction in its own executor, StackSaga enables precise control, retry, and compensation mechanisms, reducing the risk of data anomalies and ensuring eventual consistency across microservices.

====
*Understanding Atomic Operation*

An atomic transaction is a set of operations that must either all succeed or all fail as a single unit.
Within microservices, such a unit is referred to as an atomic execution.

image:executor/stacksaga-diagram-atomic-transaction.svg[]

For instance, in the placing-order scenario, there are 4 atomic operations.
Each atomic execution may itself consist of multiple service-level operations.


IMPORTANT: *Fetching user details* is quite different from the other atomic executions. because it is a read-only operation that doesn't change any state in the user-service's database.
So it can be considered as an atomic operation, but it is not a atomic transaction. but others are atomic transactions. because they change the state in their respective service's databases.

Understanding the atomic execution is crucial for implementing the executors correctly in StackSaga.
because there is no rollback mechanism after committing each atomic executions onm their service's databases.

====

Typically, an atomic execution consists of two phases: *primary execution* and *compensating execution*.

. *Primary Execution (Main Execution)*
- The primary execution represents the core operation within a long-running transaction.
Each primary execution is a distinct step in the overall business workflow, advancing the process toward completion.
These operations are generally idempotent and isolated, ensuring they can be executed independently without unintended side effects.
+
For example, in a place-order workflow, primary executions might include fetching user details, initializing the order, performing pre-authorization, updating stock, and processing the final payment.

- These primary executions move the process forward. [icon:arrow-circle-right[1x,role=green]]

. *Compensating Execution (Revert Execution)*
- A compensating execution is designed to undo the effects of a previously completed primary execution if a subsequent step fails.
Each primary execution has a corresponding compensating action to reverse its impact, ensuring the system can return to a consistent state in the event of a failure.

- Compensating executions move the process backward. [icon:arrow-circle-left[1x,role=green]]

== Executor types

Based on the above classification, the saga executors are two types in StackSaga.

* Command executors
+
If some atomic execution has both primary execution and compensating, those kinds of atomic transactions should be implemented inside the command executor. +
In *Command executor* has two methods for making the primary execution and making the compensating execution.
(See the command executor xref:framework:command_executor.adoc[implementation] or xref:framework:command_executor.adoc[read more])
+
*Examples Executions for command-executor*:
+
** Initialize order
** Reserve the items
** Make the payment


* Query executors
+
If the atomic execution has only the primary execution, those kinds of executions should be implemented inside the Query executor.
+
In *Query Executor* has only one method for making the primary execution.
(See the query executor xref:framework:query_executor.adoc[implementation] or xref:framework:query_executor.adoc[read more])
+
*Example Executions for query-executor*:
+
** collecting user delivery details +
because it doesn't make any change to the user-service's database. it's a read-only operation.



The below diagram shows the Executors types and what are the methods they have.

image:executor/stack-saga-e-store-example-executor-types-in-stacksaga.drawio.svg[alt="Stacksaga Executors",height=300]

== Guidelines for Creating Executors

Each saga executor should encapsulate a single atomic transaction.
This means you must not implement multiple atomic transactions within the same executor.

The primary reason for this restriction is that the executor acts as a retryable unit managed by the Saga Orchestration Engine (SEC).
If an executor contains multiple atomic transactions and a failure occurs, the SEC cannot determine which specific transaction failed.
For example, if an executor performs three atomic transactions and the third one fails, retrying the executor will re-execute the first and second transactions, potentially leading to duplicate operations if those steps are not idempotent.

This approach can result in data anomalies such as redundancy, integrity violations, and consistency issues.
Additionally, if a compensating (rollback) action is required, the SEC lacks the granularity to identify which atomic transaction needs to be reverted, since it treats the executor as a single atomic unit.

== Executions Classifying Tips

When you are creating the executors, you have to decide that whether the executor is a *command-executor* or *query-executor*.
To determine that the following chart will be helpful (from the database prospective).

The summary of the chart is that if the atomic execution is a *read-only* one, it should be implemented in a *query-executor*, and if the atomic operation does some state change on any database, that atomic operation should be implemented in a *command-executor*.

|===
|Operation |Has a Revert | Executor Type

|*C* - Create
|*YES*
|Command-Executor


|*R* - Read
|*NO*
|Query-Executor

|*U* - Update
|*YES*
|Command-Executor

|*D* - delete
|*YES*
|Command-Executor
|===

For instance, let's classify the executions that we have in our placing-order example.

|===
|Execution |Executor Type | Reason

|Collecting user's delivery details
|Query-Executor
|Fetching data doesn't make an impact on the user-service's database.

|Initialzie the order
|Command-Executor
|The order should be canceled if any upcoming atomic transaction is failed after initializing the order.

|Making Pre-Auth
|Command-Executor
|The Pre-Auth should be canceled if any upcoming atomic transaction is failed after making the Pre-Auth.

|Updating The Stock
|Command-Executor
|The Stock should be restored if any upcoming atomic transaction is failed after reducing the stock.

|Making Real Payment
|Command-Executor
|The Payment should be refunded if any upcoming atomic transaction is failed after making the payment.

|===

NOTE: In the placing-order example, there is no any atomic operation after making the payment.
But as the theory, making payment execution should be executed withing a command-executor.
because, for instance, if a new another atomic process is added in the future after making the payment, you must implement the compensating execution for making the payment.

[[sub-executors]]
include::sub-executors.adoc[]

== Combine multiple atomic executions

TIP: There are two possibilities to implement multiple atomic operations in the saga executor.
You know already there are two types of atomic executions in Stacksaga called command executions and query executions.
The query executions can sometimes be used together in the same executor based on the use case. +

Using multiple read-only atomic operations inside the same executor can reduce the event sourcing overhead.
Because you know that after each executor, the new state of the aggregator is stored as a new event in the database by the Saga engine.
For instance, if you implement 3 read-only atomic transactions in the same executor, you can reduce the event sourcing overhead by 2.
Because if we added those 3 executions to the 3 executors, 3 times the event store is updated after each execution. +

*First way*:

image:executor/stacksaga-diagram-combine-multiple-executor-option-1.drawio.svg[]

*Second way*:

image:executor/stacksaga-diagram-combine-multiple-executor-option-2.drawio.svg[]

