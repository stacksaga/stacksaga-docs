:description: Learn how to integrate the Stacksaga MySQL Agent for orchestrating and retrying distributed transactions in Spring Boot microservices. Discover configuration, thread pool management, and token range partitioning for robust MySQL-based event store processing.
:keywords: Stacksaga, MySQL Agent, Spring Boot, Distributed Transactions, Transaction Retrying, Microservices, Event Store, Thread Pool, Token Range, Orchestrator, R2DBC, Resilience, Java, Scheduler, stacksaga-agent-mysql-starter

:starter_name: stacksaga-agent-mysql-starter
:data_source: R2DBC Mysql datasource
:data_source_prefix: spring.r2dbc.*

= Stacksaga Mysql Agent

== `stacksaga-agent-mysql-starter`

`{starter_name}` is one of the xref:implementations:stacksaga-sync/stacksaga-agent/overview/stacksaga-agent.adoc[Stacksaga Agent implementations] that for supporting Mysql based Orchestrator services for retrying the transactions.
`stacksaga-agent-mysql` is a *ready to use* dependency.
you can create your own spring boot project and add the `{starter_name}` as a dependency and run your application with few configurations.

IMPORTANT: `{starter_name}` internally uses runs with reactive model. so make sure to create your agent application as a WebFlux spring boot application.

.Adding `{starter_name}` as a dependency
[source,xml]
----
<dependency>
    <groupId>org.stacksaga</groupId>
    <artifactId>stacksaga-agent-mysql-starter</artifactId>
    <version>${org.stacksaga.version}</version>
</dependency>
----

After adding the dependency, update the xref:#configuration-properties[configuration properties] of the application as needed.

== Transaction retrying with `stacksaga-agent-mysql`

NOTE: If you are totally new to stacksaga-agent, read the xref:ROOT:stacksaga-agent.adoc[Common approach of Stacksaga Agent] article first.

As mentioned there, the agent acquires a token range for retrying from the entire transaction set from the event store.
A scheduler is triggered with the configured time, and the retrying process is started by retreating the transactions from the event store.
Retrieving the transactions from the event store is processed batch-wise.
For instance, if you have configured batch size as 100 and if there are 1000 transactions to be retried in the event store, the loop is run 10 times sequentially like fetches 10 transactions by updating their retry-retention time and shares that 10 transactions to the available services to process.
We discussed the process of how one thread is involved in the process.
But the reality is that multiple threads do the same task in parallel in the application.
There is a configured thread pool called StackSagaRetryExecutorPool.
For instance, if the thread poolâ€™s thread size is 3 as per the diagram, the token range that has been assigned to the respective node is divided into sub-ranges again.
The sub-ranges are assigned for each thread.
Then they do the same task individually based on their respective token range.
After fetching the data from the event store by each thread, the transactions are transferred to another thread pool called StackSagaPublisherExecutorPool.
It is responsible for collecting the transactions that each thread collects from the event store.

Let's have a look at the process step by step.

image::stacksaga-agent/mysql-agent/stacksaga-diagram-stacksaga-service-agent-mysql-how-retry-is-done.svg[]

IMPORTANT: While fetching the retryable transactions from the event-store, the expired transactions also are retrieved for re-invoking if the configured expiry time (configured expiry time is set from the xref:stacksaga-database-support:mysql-database-support/stacksaga-mysql-support.adoc[Mysql database support]) is exceeded.

*The steps are as follows:*

. The scheduler is triggered
. Once the scheduler is triggered, the retrying process is started.
At this moment, the node knows about their respective token range.
And it has been divided again into sub-rangers identical to the configured pool size.
As per diagram, the pool size is 3. Just imagine only one instance is running on the given region.
Then this node acquires the entire token range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. And again, the range is divided into 3 sub-ranges due to the pool size is 3 like below.

* *Thread-1*: `-9,223,372,036,854,775,808` To `-3,074,457,345,618,258,603`
+
Thread-1 is responsible for fetching the transactions from the event store between the above range.
* *Thread-2*: `-3,074,457,345,618,258,602` To `3,074,457,345,618,258,602`
+
Thread-2 is responsible for fetching the transactions from the event store between the above range.
* *Thread-3*: `3,074,457,345,618,258,603` To `9,223,372,036,854,775,807`
+
Thread-3 is responsible for fetching the transactions from the event store between the above range.
+
NOTE: If you deploy 2 agent nodes in the region, the token rage is divided into two like and 3 sub ranges for each like below
+
[cols="1,1,2,2",options="header"]
|===
| Node   | Thread Name  | Start Token                   | End Token
| Node 1 | Thread-1 | -9,223,372,036,854,775,808  | -6,148,914,691,236,517,206
| Node 1 | Thread-2 | -6,148,914,691,236,517,205  | -3,074,457,345,618,258,603
| Node 1 | Thread-3 | -3,074,457,345,618,258,602  | 0
| Node 2 | Thread-1 | 1                            | 3,074,457,345,618,258,603
| Node 2 | Thread-2 | 3,074,457,345,618,258,604   | 6,148,914,691,236,517,206
| Node 2 | Thread-3 | 6,148,914,691,236,517,207   | 9,223,372,036,854,775,807
|===
+
. Each thread adds all the fetching transactions to the *StackSagaPublisherExecutorPool*'s queue.
. *StackSagaPublisherExecutorPool*'s threads will send the transactions to the available services to process them. and finally, each orchestrator service will receive the transactions and execute them.

NOTE: The Transaction retrying process is the same for both `eureka` and `k8s` profiles.

include::agent-common:profiles/agent-profile.adoc[leveloffset=+0]

[[configuration-properties]]
include::stacksaga_mysql_agent_configuration_properties.adoc[leveloffset=+0]