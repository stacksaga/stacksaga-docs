=== Creating PreAuthExecutor (Command-Executor)

`PreAuthExecutor` is responsible for making `PreAuth` by calling to the utility  `payment-service`.
Due to the execution should be reverted if the entire process is not successful as wished, the `PreAuthExecutor` is implemented from the `CommandExecutor` interface.
TO make the PreAuth request, we should provide the `userId`, `amount` and `orderId`.
And to revert the process we have to provide the `PreAuthRef` back.

[source,java]
----

// <1>
@SagaExecutor(executeFor = "payment-service", liveCheck = false, value = "PreAuthExecutor")
@RequiredArgsConstructor
public class PreAuthExecutor implements CommandExecutor<PlaceOrderAggregator> { // <2>
    private final PaymentService paymentService;

    @Override
    public ProcessStepManager<PlaceOrderAggregator> doProcess(
            PlaceOrderAggregator currentAggregator,
            ProcessStepManagerUtil<PlaceOrderAggregator> stepManager
    ) throws RetryableExecutorException, NonRetryableExecutorException { // <3>

        // <4>
        final String preAuthRef = this.paymentService.makePreAuth(
                PreAuthDto
                        .RequestBody
                        .builder()
                        .userId(currentAggregator.getUserId())
                        .amount(currentAggregator.getAmount())
                        .orderId(currentAggregator.getAggregatorTransactionId())
                        .build()
        );
        // <5>
        currentAggregator.setPreAuthRef(preAuthRef);
        // <6>
        return stepManager.next(StockUpdateExecutor.class, OrderStatus.MADE_PRE_AUTH.name());
    }

    @Override
    public String doRevert(
            NonRetryableExecutorException processException,
            PlaceOrderAggregator finalAggregatorState,
            RevertHintStore revertHintStore
    )
    throws RetryableExecutorException { // <7>

        this.paymentService.releasePreAuth(
                PreAuthReleaseDto.RequestBody.builder()
                        // <8>
                        .pareAuthRef(finalAggregatorState.getPreAuthRef())
                        // <9>
                        .reason(processException.get("reason").orElse(""))
                        .build()
        );
        return OrderStatus.RELEASED_PRE_AUTH.name();
    }
}
----

<1> Annotate the `PreAuthExecutor` class as a `SagaExecutor` by using `@SagaExecutor` annotation.
+
> Read more about xref:framework:saga_executors.adoc#saga_executors[`@SagaExecutor`] annotation.

<2> Implement the `PreAuthExecutor` from the `CommandExecutor` by passing the target Aggregator.
+
Read more about xref:framework:saga_executors.adoc#query_executor[`QueryExecutor<A>`] interface.

<3> you will have the `currentAggregator` object through the method parameter. due to this executor is the 3d executor, the `currentAggregator` object has been updated by the `OrderController`(initialization), `UserDetailExecutor`,and `OrderInitializeExecutor`.

<4> make the pre-auth process by invoking the PaymentService's `makePreAuth()` method.

<5> Update the `currentAggregator` with `preAuthRef` data that received as the response.

<6> Navigates the execution by using `stepManager` to the next executor called `StockUpdateExecutor`.
And also passed the status as `MADE_PRE_AUTH`.

<7> `RetryableExecutorException` As per the StackSaga design pattern the revert process cannot have any `NonRetryableExecutorException` error.
It only can have `RetryableExecutorException`.

<8> For Calling the PaymentService's `releasePreAuth()` we have to provide the `pareAuthRef` data.
So we have the last aggregator data that was updated until the end of the process to forward.
Therefore, that contains the `pareAuthRef` and we can access it from the `finalAggregatorState`.

<9> And As well as a reason should be given for the releasing `PreAuth`.
All the time the process can be failed (With  `NonRetryableExecutorException`)we have added a data called `reason` with the `NonRetryableExecutorException`.
This is the time that can be used.

=== Creating PaymentService

`PaymentService` is a regular spring service that creates for calling utility `payment-service`.
Due to the `payment-service` is another utility service we have to call it through http or any other protocol that target service supports (Most probably API endpoints are exposed by http protocol).
This example's `payment-service` also support http endpoint to access the API.
Therefore, we will be using rest template as http client.
But you can use any Http client like Feign-client, Okhttp, Spring-webclient and so on.


TIP: The relationship between the executor and service should not be *one-to-one*.
A service can be used for many executors.
In this example, the `PaymentService` class is used for `PreAuthExecutor` both executors.

[source,java]
----
@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final RestTemplate restTemplate;

    public String makePreAuth(PreAuthDto.RequestBody requestBody) throws RetryableExecutorException, NonRetryableExecutorException {
        try {
            PreAuthDto.ResponseBody responseBody = this.restTemplate.postForObject(
                    "http://payment-service/pre-auth",
                    requestBody,
                    PreAuthDto.ResponseBody.class
            );
            assert responseBody != null;
            return responseBody.getPreAuthRef();
        } catch (HttpClientErrorException ex) {
            // This exception is thrown for HTTP 4xx errors (Client errors)
            // You can handle specific HTTP error codes here
            if (ex.getStatusCode().equals(HttpStatus.FORBIDDEN)) {
                throw NonRetryableExecutorException
                        .buildWith(
                                new InsufficientBalanceException("Balance not sufficient"),
                                ""
                        )
                        .build();
            } else {
                throw NonRetryableExecutorException.buildWith(ex, "").build();
            }
        } catch (HttpServerErrorException ex) {
            // This exception is thrown for HTTP 5xx errors (Server errors)
            // You can handle specific HTTP error codes here
            if (ex.getStatusCode().equals(HttpStatus.INTERNAL_SERVER_ERROR)) {
                throw NonRetryableExecutorException.buildWith(ex, "").build();
            } else {
                //502 , 503, 504, 509 etc.
                throw RetryableExecutorException.buildWith(ex).build();
            }
        } catch (RestClientException ex) {
            // This exception is a generic RestClientException
            // Handle other types of exceptions here
            throw ex;
        }

    }

    public void releasePreAuth(PreAuthReleaseDto.RequestBody requestBody) throws RetryableExecutorException {
        try {
            this.restTemplate.put(
                    "http://payment-service/pre-auth/release",
                    requestBody
            );
        } catch (HttpClientErrorException ex) {
            // This exception is thrown for HTTP 4xx errors (Client errors)
            // You can handle specific HTTP error codes here
            throw ex;
        } catch (HttpServerErrorException ex) {
            // This exception is thrown for HTTP 5xx errors (Server errors)
            // You can handle specific HTTP error codes here
            if (ex.getStatusCode().equals(HttpStatus.INTERNAL_SERVER_ERROR)) {
                throw ex;
            } else {
                //502 , 503, 504, 509 etc.
                throw RetryableExecutorException.buildWith(ex).build();
            }
        } catch (RestClientException ex) {
            // This exception is a generic RestClientException
            // Handle other types of exceptions here
            throw ex;
        }
    }
}
----
