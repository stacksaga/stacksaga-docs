====  Creating the aggregator

You know that the request comes to the order-service first (for downstream services), and it tries to handle the entire request by calling other utility services one by one in a sequence order.
To start the execute the request, the `order-service` should have an xref:architecture:aggregator.adoc[Aggregator] class that extend from the `SagaAggregator` class.
The custom aggregator class contains all the data which used for all the atomic transactions.

In addition to that, to verify whether the aggregator object is serializable or not, we should provide a xref:framework:aggregator_serialization.adoc[SagaSerializable] implementation.
It ensures that the aggregator can be serialized and deserialized when the application is started.
The advantages of providing the `SagaSerializable` is that if there is any issue when the aggregator is serialized and deserialized, it will be indicated when the application is started.
Otherwise, the error comes when a transaction is being processed.

Furthermore, to verify whether the aggregator object is serializable, it is recommended to provide a xref:framework:aggregator_serialization.adoc[SagaSerializable] implementation for the relevant aggregator.
This ensures that the aggregator can be correctly serialized and deserialized during application startup.
The primary advantage of providing a SagaSerializer is that any serialization or deserialization issues will be detected at startup, rather than during transaction processing, thereby preventing runtime failures.
If you don't provide the `SagaSerializer`, the default SagaSerializer is used. it also checks whether the aggregator is serializable or not by creating an object internally. but if you are using more complex data structure, it is recommended to provide the `SagaSerializable` implementation for the relevant aggregator.

[source,java]
----
package org.example.aggregator;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import lombok.Setter;
import org.example.aggregator.dto.OrderItem;
import org.stacksaga.Aggregator;
import org.stacksaga.SagaSerializable;
import org.stacksaga.core.annotation.SagaAggregator;
import org.stacksaga.core.annotation.SagaAggregatorVersion;

import java.util.List;

@SagaAggregator(
        version = @SagaAggregatorVersion(major = 1, minor = 0, patch = 0),
        name = "PlaceOrderAggregator",
        sagaSerializable = PlaceOrderAggregatorSerializer.class
)
@Getter
@Setter
@ToString
public class PlaceOrderAggregator extends Aggregator {


    /**
     * The relevant user to the order.
     */
    @JsonProperty("user_id")
    private String userId;
    /**
     * The item list that user order.
     */
    @JsonProperty("items")
    private List<OrderItem> items;

    /**
     * The amount to be paid.
     */
    @JsonProperty("amount")
    private Double amount;

    /**
     * Pre-Auth Reference for release or make the payment.
     */
    @JsonProperty("pre_auth_ref")
    private String preAuthRef;

    /**
     * Payment ID after the payment.
     */
    @JsonProperty("payment_id")
    private String paymentId;

    @JsonProperty("executions")
    private List<String> executions = new ArrayList<>();

    @JsonIgnore
    private Boolean hasRevertError = false;

    public PlaceOrderAggregator() {
        super(PlaceOrderAggregator.class);
    }
}


class PlaceOrderAggregatorSerializer extends SagaSerializable<PlaceOrderAggregator> {

    public PlaceOrderAggregatorSerializer() {
        PlaceOrderAggregator placeOrderAggregator = new PlaceOrderAggregator();
        placeOrderAggregator.setUserId("user-1");
        placeOrderAggregator.setAmount(100.00);
        placeOrderAggregator.setItems(new ArrayList<>());
        placeOrderAggregator.getItems()
                .add(OrderItem.builder()
                        .itemId("item-1")
                        .itemPrice(100.00)
                        .build()
                );
        this.put("sample-1", placeOrderAggregator);
    }
}
----

TIP: To make the code more readable and clear, I have used https://projectlombok.org/:[`lombok`]
and builder pattern for creating the objects through the demo.
It is not required, and you are free to use the traditional way by creating getters and setters manual.

In the `PlaceOrderAggregator` has the data that we want to access while the entire transaction process.
Those data will be updated time to time from each execution.

Now the aggregator is ready to store and carry out the data throughout the entire process.

