====  Creating executors

You know that we have to access more services except this `order-service` to fully complete the place-order request.
To access those services in general, you would use *service-layer* and call those services by using any httpclient like RestTemplate, Feign client, Okhttp, and so on.
But in the xref://[Saga design pattern], you know that we should have a compensation process for all the execution (All the executions that make some changes in a database).
Due to the fact that the StackSaga framework is one of Saga implementations, it should be provided the main execution and also a compensation execution to make a compensation when the entire process is failed at any point.

> Read the xref://[reference documentation]
to have a better understanding and best practices regarding the `SagaExecutors`.

StackSaga doesn't bother to that layer.
In StackSaga, In addition to that layer you have to implement a new layer called `*executor-layer*`.
In the executor-layer, you can create your executors.

All the *process-executions* (The regular execution to make the process) and *revert-executions* (The compensation executions to undo the made changes by process-executions) with the relevant services are summarized in the following table and the diagram.

[.scrollable]
--
[cols=".no-wrap, .normal, .no-wrap, .no-wrap, .no-wrap, .no-wrap"]
|===
|Executor Class Name| Execution_Requirement | Target_Service | Type | Process-Execution |  Revert-Execution

|xref://[`OrderInitializeExecutor`]
|Initialize the order at the first.
|`order-service`
|[.badge-yellow]*COMMAND_EXECUTOR*
|`initializeOrder()`
|`cancelOrder()`

|xref://[`UserDetailExecutor`]
|Fetch the user's details
|`user-service`
|[.badge-green]*QUERY_EXECUTOR*
|`getUserDetails`
| -

|xref://[`PreAuthExecutor`]
|Make the Pre-Auth process.
|`payment-service`
|[.badge-yellow]*COMMAND_EXECUTOR*
|`makePreAuth()`
|`releasePreAuth()`

|xref://[`StockUpdateExecutor`]
|Update the stock from the store.
|`stock-service`
|[.badge-yellow]*COMMAND_EXECUTOR*
|`updateStock()`
|`restoreStock()`

|xref://[`MakePaymentExecutor`]
|Finalize the order by making the real payment.
|`payment-service`
|[.badge-yellow]*COMMAND_EXECUTOR*
|`makePayment()`
| ?

|===

--

image:stacksaga-example-executors.drawio.svg[alt="stacksaga-example executors digram."]

In the diagram, you can see cleanly what we are going to build inside the order-service and how they connect with other services.

Even though the class creation should be started from the repository-layer, let's get started from the executor-layer for your convenience to understand.

=== Creating OrderInitializeExecutor

You know that the request comes to the `OrderController`
and the request is transferred to the `OrderInitializeExecutor` as the first step.
And next, we want to decide what OrderInitializeExecutor class type should be.
That means that there are two executor types in StackSga called xref:framework:command_executor.adoc[CommandExecutor] and xref:framework:query_executor.adoc[QueryExecutor].

The OrderInitializeExecutor should be a command-executor because if a failure occurred at some point after executing the order initialization process, it should be recovered again.
Here we mark the order as canceled.

.https://github.com/stacksaga/stacksaga-examples/blob/main/stacksaga-demo-for-kubernetes/order-service/src/main/java/org/example/executor/OrderInitializeExecutor.java[icon:github[role=black,size=2x] OrderInitializeExecutor.class]
[source,java]
----
// <1>
@SagaExecutor(executeFor = "order-service", liveCheck = false, value = "OrderInitializeExecutor")
@RequiredArgsConstructor
public class OrderInitializeExecutor implements CommandExecutor<PlaceOrderAggregator> { // <2>

    // <3>
    private final OrderService orderService;
    private final ObjectMapper objectMapper;

    @Override // <4>
    public ProcessStepManager<PlaceOrderAggregator> doProcess(PlaceOrderAggregator currentAggregator, ProcessStepManagerUtil<PlaceOrderAggregator> stepManager) throws RetryableExecutorException, NonRetryableExecutorException {
        try {
            // <5>
            this.orderService.initialize(
                    OrderEntity
                            .builder()
                            .orderID(currentAggregator.getAggregatorTransactionId())
                            .createAt(LocalDateTime.now())
                            .isCancelled(false)
                            .items(objectMapper.writeValueAsString(currentAggregator.getItems()))
                            .build()
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        // <6>
        return stepManager.next(UserDetailExecutor.class, OrderStatus.INITIALIZED_ORDER.name());
    }

    @Override // <4>
    public String doRevert(NonRetryableExecutorException processException, PlaceOrderAggregator finalAggregatorState, RevertHintStore revertHintStore) throws RetryableExecutorException {
        // <7>
        this.orderService.cancelOrder(finalAggregatorState.getAggregatorTransactionId());
        // <8>
        return OrderStatus.CANCELED_ORDER.name();
    }
}
----

<1> Annotate the `OrderInitializeExecutor` class as a `SagaExecutor` by using `@SagaExecutor` annotation.
+
Read more about xref:framework:saga_executors.adoc#saga_executors[`@SagaExecutor`] annotation.
<2> The class has been extended from the `CommandExecutor`.
+
Read more about xref:framework:saga_executors.adoc#command_executor[`CommandExecutor`] annotation.

<3> Autowire the https://github.com/stacksaga/stacksaga-examples/blob/main/stacksaga-demo-for-kubernetes/order-service/src/main/java/org/example/service/internal/OrderService.java[`OrderService`] service to make the execution.
(`ObjectMapper` has been Autowired just for getting the JSON string)
<4> Overridden the `doProcess` and `doRevert` methods.

<5> Calling the initialize-method to invoke the execution.
(This method is invoked by the framework with different thread-pool.)

<6> After invoking the execution successfully, `stepManager.next` command guides the framework what is the next execution after this execution. Our next execution should be make