[[stacksaga-kafka-endpoints]]
== Stacksaga Kafka Endpoints

Stacksaga Kafka Endpoints stands for creating topics accordingly Stacksaga engine's form. the endpoint As per the architecture it can be created 3 types of endpoints as fallows,

. *xref:#query-endpoints[]*
. *xref:#command-endpoints[]*
. *xref:#revert-endpoints[]*


// image::stacksaga-kafka/stacksaga-kafka-client/stacksaga-kafka-engine-stacksaga-kafka-endpoints.svg[]

[[query-endpoints]]
=== Query Endpoints

If an execution(atomic execution) doesn't make any state change due to executing that execution those kinds of executions are executed in *Query Endpoints*. due to it doesn't make any changes in the database state, it has no any compensation action to undo. +
these are the topics that define in the in xref:stacksaga-kafka/saga-topic/saga-topic.adoc[] with type of `SagaTopicType.QUERY_DO_ACTION`

- Each Query Endpoint creates one topic in kafka.
** `DO_VALIDATE_USER` (primary execution topic)
** the topic name should be started with `DO_`

image:stacksaga-kafka/stacksaga-kafka-client/stacksaga-kafka-engine-query-endpoint.svg[]

As per the above diagram,

* the orchestrator service(order-service) trigger an event via the xref:stacksaga-kafka/saga-step-manager/saga-event-navigator.adoc[] the topic of `DO_VALIDATE_USER`(the event is triggered by the SEC behind the sense accordingly your navigation in the xref:stacksaga-kafka/saga-step-manager/saga-event-navigator.adoc[]).

*

[[command-endpoints]]
=== Command Endpoints

if an execution(atomic execution) make some state change in the database of the respective service those kinds of executions are executed in *Command Endpoints*. due to the fact that it make some state changes in the database of the respective service, in case of failure, the changes should be restored by invoking compensation reaction.
these are the topics that define in the in xref:stacksaga-kafka/saga-topic/saga-topic.adoc[] with type of `SagaTopicType.QUERY_DO_ACTION`

- Each Command Endpoint creates two topics in kafka for the primary execution and the compensation execution.
** `DO_MAKE_PAYMENT` (primary execution topic)
*** the topic name should be started with `DO_`
** `UNDO_MAKE_PAYMENT` (compensating execution topic)
*** the topic name should be started with `UNDO_`

image:stacksaga-kafka/stacksaga-kafka-client/stacksaga-kafka-engine-command-endpoint.svg[]

[[revert-endpoints]]
=== Revert Endpoints

in Command Endpoints,there is a compensation execution for revering. in case if you want to add more execution before or after when the compensation execution is done, you can create *Revert Endpoints* to execute those kind of executions.

- Each Revert Endpoint creates one topic in kafka.
** `REVERT_MAKE_PAYMENT_LOG` (sub compensating execution topic)

image:stacksaga-kafka/stacksaga-kafka-client/stacksaga-kafka-engine-revert-endpoints.svg[]

[[Endpoint-annotation]]
== @Endpoint Annotation

`@Endpoint` Annotation is used for annotating the custom saga endpoint classes, and it has been inherited from spring `@Component`.
the annotation has two parameters as follows,

* `value`: the name of the bean in spring. is it not required to be provided.
* `eventName`: The name of the event action. +
For instance, if we create an endpoint for making the payment, the `eventName` name would be `MAKE_PAYMENT`.
+
IMPORTANT: Even though the `eventName` can be any name, it would be related to the real endpoint's topic name in kafka. +
for instance, if we set the `eventName` as `MAKE_PAYMENT` for our xref:command-endpoints[], the real topic name for the primary execution's topic name should be `DO_MAKE_PAYMENT` and the revert(compensation) execution's topic name should be `UNDO_MAKE_PAYMENT`. it is validated by the framework when the application is started and if there are not matched, it will throw an exception. +

[[SagaEndpointListener-annotation]]
== @SagaEndpointListener Annotation

`@SagaEndpointListener` is a StackSaga annotation used to designate a method as a Kafka message listener following the StackSaga framework’s conventions and style.
It is an inherited and optimized version of Spring’s `@KafkaListener`, tailored specifically to suit StackSaga’s requirements. +
most of the parameters can be configured as usual from `@KafkaListener`.
but some of requires have been configured internally by the framework like `containerFactory` , `groupId` etc.